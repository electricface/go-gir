/*
 * Copyright (C) 2019 ~ 2020 Uniontech Software Technology Co.,Ltd
 *
 * Author:
 *
 * Maintainer:
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// Code generated by "girgen"; DO NOT EDIT.

package gom

import "github.com/linuxdeepin/go-gir/g-2.0"
import "github.com/linuxdeepin/go-gir/gi"
import "log"
import "unsafe"

var _I = gi.NewInvokerCache("Gom")
var _ unsafe.Pointer
var _ *log.Logger

func init() {
	repo := gi.DefaultRepository()
	_, err := repo.Require("Gom", "1.0", gi.REPOSITORY_LOAD_FLAG_LAZY)
	if err != nil {
		panic(err)
	}
}

// Object Adapter
type Adapter struct {
	g.Object
}

func WrapAdapter(p unsafe.Pointer) (r Adapter) { r.P = p; return }

type IAdapter interface{ P_Adapter() unsafe.Pointer }

func (v Adapter) P_Adapter() unsafe.Pointer { return v.P }
func AdapterGetType() gi.GType {
	ret := _I.GetGType(0, "Adapter")
	return ret
}

// gom_adapter_new
//
// [ result ] trans: everything
//
func NewAdapter() (result Adapter) {
	iv, err := _I.Get(0, "Adapter", "new", 0, 0, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// gom_adapter_close_async
//
// [ callback ] trans: nothing
//
// [ user_data ] trans: nothing
//
func (v Adapter) CloseAsync(callback g.AsyncReadyCallback) {
	iv, err := _I.Get(1, "Adapter", "close_async", 0, 1, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var funcPtr unsafe.Pointer
	if callback != nil {
		callableInfo := gi.GetCallableInfo("Gio", "AsyncReadyCallback")
		_, funcPtr = gi.RegisterFClosure(func(__result unsafe.Pointer, __args []unsafe.Pointer) {
			g.CallAsyncReadyCallback(callback, __result, __args)
		}, gi.ScopeAsync, callableInfo)
		callableInfo.Unref()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_callback := gi.NewPointerArgument(funcPtr)
	arg_user_data := gi.NewPointerArgument(nil)
	args := []gi.Argument{arg_v, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// gom_adapter_close_finish
//
// [ result ] trans: nothing
//
// [ result1 ] trans: nothing
//
func (v Adapter) CloseFinish(result g.IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(2, "Adapter", "close_finish", 0, 2, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// gom_adapter_close_sync
//
// [ result ] trans: nothing
//
func (v Adapter) CloseSync() (result bool, err error) {
	iv, err := _I.Get(3, "Adapter", "close_sync", 0, 3, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// gom_adapter_execute_sql
//
// [ sql ] trans: nothing
//
// [ result ] trans: nothing
//
func (v Adapter) ExecuteSql(sql string) (result bool, err error) {
	iv, err := _I.Get(4, "Adapter", "execute_sql", 0, 4, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_sql := gi.CString(sql)
	arg_v := gi.NewPointerArgument(v.P)
	arg_sql := gi.NewStringArgument(c_sql)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_sql, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_sql)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// gom_adapter_get_handle
//
// [ result ] trans: nothing
//
func (v Adapter) GetHandle() (result unsafe.Pointer) {
	iv, err := _I.Get(5, "Adapter", "get_handle", 0, 5, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Pointer()
	return
}

// gom_adapter_open_async
//
// [ uri ] trans: nothing
//
// [ callback ] trans: nothing
//
// [ user_data ] trans: nothing
//
func (v Adapter) OpenAsync(uri string, callback g.AsyncReadyCallback) {
	iv, err := _I.Get(6, "Adapter", "open_async", 0, 6, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_uri := gi.CString(uri)
	var funcPtr unsafe.Pointer
	if callback != nil {
		callableInfo := gi.GetCallableInfo("Gio", "AsyncReadyCallback")
		_, funcPtr = gi.RegisterFClosure(func(__result unsafe.Pointer, __args []unsafe.Pointer) {
			g.CallAsyncReadyCallback(callback, __result, __args)
		}, gi.ScopeAsync, callableInfo)
		callableInfo.Unref()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_uri := gi.NewStringArgument(c_uri)
	arg_callback := gi.NewPointerArgument(funcPtr)
	arg_user_data := gi.NewPointerArgument(nil)
	args := []gi.Argument{arg_v, arg_uri, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_uri)
}

// gom_adapter_open_finish
//
// [ result ] trans: nothing
//
// [ result1 ] trans: nothing
//
func (v Adapter) OpenFinish(result g.IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(7, "Adapter", "open_finish", 0, 7, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// gom_adapter_open_sync
//
// [ uri ] trans: nothing
//
// [ result ] trans: nothing
//
func (v Adapter) OpenSync(uri string) (result bool, err error) {
	iv, err := _I.Get(8, "Adapter", "open_sync", 0, 8, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_uri := gi.CString(uri)
	arg_v := gi.NewPointerArgument(v.P)
	arg_uri := gi.NewStringArgument(c_uri)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_uri, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_uri)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// gom_adapter_queue_read
//
// [ callback ] trans: nothing
//
// [ user_data ] trans: nothing
//
func (v Adapter) QueueRead(callback AdapterCallback) {
	iv, err := _I.Get(9, "Adapter", "queue_read", 0, 9, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var funcPtr unsafe.Pointer
	if callback != nil {
		callableInfo := gi.GetCallableInfo("Gom", "AdapterCallback")
		_, funcPtr = gi.RegisterFClosure(func(__result unsafe.Pointer, __args []unsafe.Pointer) {
			CallAdapterCallback(callback, __result, __args)
		}, gi.ScopeAsync, callableInfo)
		callableInfo.Unref()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_callback := gi.NewPointerArgument(funcPtr)
	arg_user_data := gi.NewPointerArgument(nil)
	args := []gi.Argument{arg_v, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// gom_adapter_queue_write
//
// [ callback ] trans: nothing
//
// [ user_data ] trans: nothing
//
func (v Adapter) QueueWrite(callback AdapterCallback) {
	iv, err := _I.Get(10, "Adapter", "queue_write", 0, 10, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var funcPtr unsafe.Pointer
	if callback != nil {
		callableInfo := gi.GetCallableInfo("Gom", "AdapterCallback")
		_, funcPtr = gi.RegisterFClosure(func(__result unsafe.Pointer, __args []unsafe.Pointer) {
			CallAdapterCallback(callback, __result, __args)
		}, gi.ScopeAsync, callableInfo)
		callableInfo.Unref()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_callback := gi.NewPointerArgument(funcPtr)
	arg_user_data := gi.NewPointerArgument(nil)
	args := []gi.Argument{arg_v, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

type AdapterCallback func(adapter Adapter)

func CallAdapterCallback(fn AdapterCallback, result unsafe.Pointer, args []unsafe.Pointer) {
	if fn == nil {
		return
	}
	adapter := WrapAdapter(*(*unsafe.Pointer)(args[0]))
	fn(adapter)
}

// ignore GType struct AdapterClass

// Struct AdapterPrivate
type AdapterPrivate struct {
	P unsafe.Pointer
}

func AdapterPrivateGetType() gi.GType {
	ret := _I.GetGType(1, "AdapterPrivate")
	return ret
}

// Object Command
type Command struct {
	g.Object
}

func WrapCommand(p unsafe.Pointer) (r Command) { r.P = p; return }

type ICommand interface{ P_Command() unsafe.Pointer }

func (v Command) P_Command() unsafe.Pointer { return v.P }
func CommandGetType() gi.GType {
	ret := _I.GetGType(2, "Command")
	return ret
}

// gom_command_execute
//
// [ cursor ] trans: nothing
//
// [ result ] trans: nothing
//
func (v Command) Execute(cursor ICursor) (result bool, err error) {
	iv, err := _I.Get(11, "Command", "execute", 4, 0, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cursor != nil {
		tmp = cursor.P_Cursor()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cursor := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cursor, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// gom_command_get_param_index
//
// [ param_name ] trans: nothing
//
// [ result ] trans: nothing
//
func (v Command) GetParamIndex(param_name string) (result int32) {
	iv, err := _I.Get(12, "Command", "get_param_index", 4, 1, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_param_name := gi.CString(param_name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_param_name := gi.NewStringArgument(c_param_name)
	args := []gi.Argument{arg_v, arg_param_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_param_name)
	result = ret.Int32()
	return
}

// gom_command_reset
//
func (v Command) Reset() {
	iv, err := _I.Get(13, "Command", "reset", 4, 2, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// gom_command_set_param
//
// [ param ] trans: nothing
//
// [ value ] trans: nothing
//
func (v Command) SetParam(param uint32, value g.Value) {
	iv, err := _I.Get(14, "Command", "set_param", 4, 3, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_param := gi.NewUint32Argument(param)
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_v, arg_param, arg_value}
	iv.Call(args, nil, nil)
}

// gom_command_set_param_double
//
// [ param ] trans: nothing
//
// [ value ] trans: nothing
//
func (v Command) SetParamDouble(param uint32, value float64) {
	iv, err := _I.Get(15, "Command", "set_param_double", 4, 4, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_param := gi.NewUint32Argument(param)
	arg_value := gi.NewDoubleArgument(value)
	args := []gi.Argument{arg_v, arg_param, arg_value}
	iv.Call(args, nil, nil)
}

// gom_command_set_param_float
//
// [ param ] trans: nothing
//
// [ value ] trans: nothing
//
func (v Command) SetParamFloat(param uint32, value float32) {
	iv, err := _I.Get(16, "Command", "set_param_float", 4, 5, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_param := gi.NewUint32Argument(param)
	arg_value := gi.NewFloatArgument(value)
	args := []gi.Argument{arg_v, arg_param, arg_value}
	iv.Call(args, nil, nil)
}

// gom_command_set_param_int
//
// [ param ] trans: nothing
//
// [ value ] trans: nothing
//
func (v Command) SetParamInt(param uint32, value int32) {
	iv, err := _I.Get(17, "Command", "set_param_int", 4, 6, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_param := gi.NewUint32Argument(param)
	arg_value := gi.NewInt32Argument(value)
	args := []gi.Argument{arg_v, arg_param, arg_value}
	iv.Call(args, nil, nil)
}

// gom_command_set_param_int64
//
// [ param ] trans: nothing
//
// [ value ] trans: nothing
//
func (v Command) SetParamInt64(param uint32, value int64) {
	iv, err := _I.Get(18, "Command", "set_param_int64", 4, 7, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_param := gi.NewUint32Argument(param)
	arg_value := gi.NewInt64Argument(value)
	args := []gi.Argument{arg_v, arg_param, arg_value}
	iv.Call(args, nil, nil)
}

// gom_command_set_param_string
//
// [ param ] trans: nothing
//
// [ value ] trans: nothing
//
func (v Command) SetParamString(param uint32, value string) {
	iv, err := _I.Get(19, "Command", "set_param_string", 4, 8, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_value := gi.CString(value)
	arg_v := gi.NewPointerArgument(v.P)
	arg_param := gi.NewUint32Argument(param)
	arg_value := gi.NewStringArgument(c_value)
	args := []gi.Argument{arg_v, arg_param, arg_value}
	iv.Call(args, nil, nil)
	gi.Free(c_value)
}

// gom_command_set_param_uint
//
// [ param ] trans: nothing
//
// [ value ] trans: nothing
//
func (v Command) SetParamUint(param uint32, value uint32) {
	iv, err := _I.Get(20, "Command", "set_param_uint", 4, 9, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_param := gi.NewUint32Argument(param)
	arg_value := gi.NewUint32Argument(value)
	args := []gi.Argument{arg_v, arg_param, arg_value}
	iv.Call(args, nil, nil)
}

// gom_command_set_param_uint64
//
// [ param ] trans: nothing
//
// [ value ] trans: nothing
//
func (v Command) SetParamUint64(param uint32, value uint64) {
	iv, err := _I.Get(21, "Command", "set_param_uint64", 4, 10, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_param := gi.NewUint32Argument(param)
	arg_value := gi.NewUint64Argument(value)
	args := []gi.Argument{arg_v, arg_param, arg_value}
	iv.Call(args, nil, nil)
}

// gom_command_set_sql
//
// [ sql ] trans: nothing
//
func (v Command) SetSql(sql string) {
	iv, err := _I.Get(22, "Command", "set_sql", 4, 11, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_sql := gi.CString(sql)
	arg_v := gi.NewPointerArgument(v.P)
	arg_sql := gi.NewStringArgument(c_sql)
	args := []gi.Argument{arg_v, arg_sql}
	iv.Call(args, nil, nil)
	gi.Free(c_sql)
}

// Object CommandBuilder
type CommandBuilder struct {
	g.Object
}

func WrapCommandBuilder(p unsafe.Pointer) (r CommandBuilder) { r.P = p; return }

type ICommandBuilder interface{ P_CommandBuilder() unsafe.Pointer }

func (v CommandBuilder) P_CommandBuilder() unsafe.Pointer { return v.P }
func CommandBuilderGetType() gi.GType {
	ret := _I.GetGType(3, "CommandBuilder")
	return ret
}

// gom_command_builder_build_count
//
// [ result ] trans: everything
//
func (v CommandBuilder) BuildCount() (result Command) {
	iv, err := _I.Get(23, "CommandBuilder", "build_count", 5, 0, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// gom_command_builder_build_create
//
// [ version ] trans: nothing
//
// [ result ] trans: everything
//
func (v CommandBuilder) BuildCreate(version uint32) (result g.List) {
	iv, err := _I.Get(24, "CommandBuilder", "build_create", 5, 1, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_version := gi.NewUint32Argument(version)
	args := []gi.Argument{arg_v, arg_version}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// gom_command_builder_build_delete
//
// [ result ] trans: everything
//
func (v CommandBuilder) BuildDelete() (result Command) {
	iv, err := _I.Get(25, "CommandBuilder", "build_delete", 5, 2, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// gom_command_builder_build_insert
//
// [ resource ] trans: nothing
//
// [ result ] trans: everything
//
func (v CommandBuilder) BuildInsert(resource IResource) (result Command) {
	iv, err := _I.Get(26, "CommandBuilder", "build_insert", 5, 3, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if resource != nil {
		tmp = resource.P_Resource()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_resource := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_resource}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// gom_command_builder_build_select
//
// [ result ] trans: everything
//
func (v CommandBuilder) BuildSelect() (result Command) {
	iv, err := _I.Get(27, "CommandBuilder", "build_select", 5, 4, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// gom_command_builder_build_update
//
// [ resource ] trans: nothing
//
// [ result ] trans: everything
//
func (v CommandBuilder) BuildUpdate(resource IResource) (result Command) {
	iv, err := _I.Get(28, "CommandBuilder", "build_update", 5, 5, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if resource != nil {
		tmp = resource.P_Resource()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_resource := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_resource}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// ignore GType struct CommandBuilderClass

// Struct CommandBuilderPrivate
type CommandBuilderPrivate struct {
	P unsafe.Pointer
}

func CommandBuilderPrivateGetType() gi.GType {
	ret := _I.GetGType(4, "CommandBuilderPrivate")
	return ret
}

// ignore GType struct CommandClass

// Struct CommandPrivate
type CommandPrivate struct {
	P unsafe.Pointer
}

func CommandPrivateGetType() gi.GType {
	ret := _I.GetGType(5, "CommandPrivate")
	return ret
}

// Object Cursor
type Cursor struct {
	g.Object
}

func WrapCursor(p unsafe.Pointer) (r Cursor) { r.P = p; return }

type ICursor interface{ P_Cursor() unsafe.Pointer }

func (v Cursor) P_Cursor() unsafe.Pointer { return v.P }
func CursorGetType() gi.GType {
	ret := _I.GetGType(6, "Cursor")
	return ret
}

// gom_cursor_get_column
//
// [ column ] trans: nothing
//
// [ value ] trans: nothing
//
func (v Cursor) GetColumn(column uint32, value g.Value) {
	iv, err := _I.Get(29, "Cursor", "get_column", 10, 0, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_column := gi.NewUint32Argument(column)
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_v, arg_column, arg_value}
	iv.Call(args, nil, nil)
}

// gom_cursor_get_column_boolean
//
// [ column ] trans: nothing
//
// [ result ] trans: nothing
//
func (v Cursor) GetColumnBoolean(column uint32) (result bool) {
	iv, err := _I.Get(30, "Cursor", "get_column_boolean", 10, 1, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_column := gi.NewUint32Argument(column)
	args := []gi.Argument{arg_v, arg_column}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// gom_cursor_get_column_double
//
// [ column ] trans: nothing
//
// [ result ] trans: nothing
//
func (v Cursor) GetColumnDouble(column uint32) (result float64) {
	iv, err := _I.Get(31, "Cursor", "get_column_double", 10, 2, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_column := gi.NewUint32Argument(column)
	args := []gi.Argument{arg_v, arg_column}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Double()
	return
}

// gom_cursor_get_column_float
//
// [ column ] trans: nothing
//
// [ result ] trans: nothing
//
func (v Cursor) GetColumnFloat(column uint32) (result float32) {
	iv, err := _I.Get(32, "Cursor", "get_column_float", 10, 3, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_column := gi.NewUint32Argument(column)
	args := []gi.Argument{arg_v, arg_column}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Float()
	return
}

// gom_cursor_get_column_int
//
// [ column ] trans: nothing
//
// [ result ] trans: nothing
//
func (v Cursor) GetColumnInt(column uint32) (result int32) {
	iv, err := _I.Get(33, "Cursor", "get_column_int", 10, 4, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_column := gi.NewUint32Argument(column)
	args := []gi.Argument{arg_v, arg_column}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// gom_cursor_get_column_int64
//
// [ column ] trans: nothing
//
// [ result ] trans: nothing
//
func (v Cursor) GetColumnInt64(column uint32) (result int64) {
	iv, err := _I.Get(34, "Cursor", "get_column_int64", 10, 5, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_column := gi.NewUint32Argument(column)
	args := []gi.Argument{arg_v, arg_column}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int64()
	return
}

// gom_cursor_get_column_name
//
// [ column ] trans: nothing
//
// [ result ] trans: nothing
//
func (v Cursor) GetColumnName(column uint32) (result string) {
	iv, err := _I.Get(35, "Cursor", "get_column_name", 10, 6, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_column := gi.NewUint32Argument(column)
	args := []gi.Argument{arg_v, arg_column}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Copy()
	return
}

// gom_cursor_get_column_string
//
// [ column ] trans: nothing
//
// [ result ] trans: nothing
//
func (v Cursor) GetColumnString(column uint32) (result string) {
	iv, err := _I.Get(36, "Cursor", "get_column_string", 10, 7, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_column := gi.NewUint32Argument(column)
	args := []gi.Argument{arg_v, arg_column}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Copy()
	return
}

// gom_cursor_get_column_uint
//
// [ column ] trans: nothing
//
// [ result ] trans: nothing
//
func (v Cursor) GetColumnUint(column uint32) (result uint32) {
	iv, err := _I.Get(37, "Cursor", "get_column_uint", 10, 8, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_column := gi.NewUint32Argument(column)
	args := []gi.Argument{arg_v, arg_column}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// gom_cursor_get_column_uint64
//
// [ column ] trans: nothing
//
// [ result ] trans: nothing
//
func (v Cursor) GetColumnUint64(column uint32) (result uint64) {
	iv, err := _I.Get(38, "Cursor", "get_column_uint64", 10, 9, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_column := gi.NewUint32Argument(column)
	args := []gi.Argument{arg_v, arg_column}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint64()
	return
}

// gom_cursor_get_n_columns
//
// [ result ] trans: nothing
//
func (v Cursor) GetNColumns() (result uint32) {
	iv, err := _I.Get(39, "Cursor", "get_n_columns", 10, 10, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// gom_cursor_next
//
// [ result ] trans: nothing
//
func (v Cursor) Next() (result bool) {
	iv, err := _I.Get(40, "Cursor", "next", 10, 11, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// ignore GType struct CursorClass

// Struct CursorPrivate
type CursorPrivate struct {
	P unsafe.Pointer
}

func CursorPrivateGetType() gi.GType {
	ret := _I.GetGType(7, "CursorPrivate")
	return ret
}

// Enum Error
type ErrorEnum int

const (
	ErrorAdapterOpen           ErrorEnum = 0
	ErrorCommandNoSql          ErrorEnum = 1
	ErrorCommandSqlite         ErrorEnum = 2
	ErrorRepositoryEmptyResult ErrorEnum = 3
	ErrorResourceCursor        ErrorEnum = 4
)

func ErrorGetType() gi.GType {
	ret := _I.GetGType(8, "Error")
	return ret
}

// Object Filter
type Filter struct {
	g.InitiallyUnowned
}

func WrapFilter(p unsafe.Pointer) (r Filter) { r.P = p; return }

type IFilter interface{ P_Filter() unsafe.Pointer }

func (v Filter) P_Filter() unsafe.Pointer { return v.P }
func FilterGetType() gi.GType {
	ret := _I.GetGType(9, "Filter")
	return ret
}

// gom_filter_new_and
//
// [ left ] trans: nothing
//
// [ right ] trans: nothing
//
// [ result ] trans: everything
//
func NewFilterAnd(left IFilter, right IFilter) (result Filter) {
	iv, err := _I.Get(41, "Filter", "new_and", 14, 0, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if left != nil {
		tmp = left.P_Filter()
	}
	var tmp1 unsafe.Pointer
	if right != nil {
		tmp1 = right.P_Filter()
	}
	arg_left := gi.NewPointerArgument(tmp)
	arg_right := gi.NewPointerArgument(tmp1)
	args := []gi.Argument{arg_left, arg_right}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// gom_filter_new_and_fullv
//
// [ filter_array ] trans: nothing
//
// [ result ] trans: everything
//
func NewFilterAndFullv(filter_array IFilter) (result Filter) {
	iv, err := _I.Get(42, "Filter", "new_and_fullv", 14, 1, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if filter_array != nil {
		tmp = filter_array.P_Filter()
	}
	arg_filter_array := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_filter_array}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// gom_filter_new_eq
//
// [ resource_type ] trans: nothing
//
// [ property_name ] trans: nothing
//
// [ value ] trans: nothing
//
// [ result ] trans: nothing
//
func NewFilterEq(resource_type gi.GType, property_name string, value g.Value) (result Filter) {
	iv, err := _I.Get(43, "Filter", "new_eq", 14, 2, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	arg_resource_type := gi.NewUintArgument(uint(resource_type))
	arg_property_name := gi.NewStringArgument(c_property_name)
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_resource_type, arg_property_name, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_property_name)
	result.P = ret.Pointer()
	return
}

// gom_filter_new_glob
//
// [ resource_type ] trans: nothing
//
// [ property_name ] trans: nothing
//
// [ value ] trans: nothing
//
// [ result ] trans: nothing
//
func NewFilterGlob(resource_type gi.GType, property_name string, value g.Value) (result Filter) {
	iv, err := _I.Get(44, "Filter", "new_glob", 14, 3, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	arg_resource_type := gi.NewUintArgument(uint(resource_type))
	arg_property_name := gi.NewStringArgument(c_property_name)
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_resource_type, arg_property_name, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_property_name)
	result.P = ret.Pointer()
	return
}

// gom_filter_new_gt
//
// [ resource_type ] trans: nothing
//
// [ property_name ] trans: nothing
//
// [ value ] trans: nothing
//
// [ result ] trans: nothing
//
func NewFilterGt(resource_type gi.GType, property_name string, value g.Value) (result Filter) {
	iv, err := _I.Get(45, "Filter", "new_gt", 14, 4, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	arg_resource_type := gi.NewUintArgument(uint(resource_type))
	arg_property_name := gi.NewStringArgument(c_property_name)
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_resource_type, arg_property_name, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_property_name)
	result.P = ret.Pointer()
	return
}

// gom_filter_new_gte
//
// [ resource_type ] trans: nothing
//
// [ property_name ] trans: nothing
//
// [ value ] trans: nothing
//
// [ result ] trans: nothing
//
func NewFilterGte(resource_type gi.GType, property_name string, value g.Value) (result Filter) {
	iv, err := _I.Get(46, "Filter", "new_gte", 14, 5, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	arg_resource_type := gi.NewUintArgument(uint(resource_type))
	arg_property_name := gi.NewStringArgument(c_property_name)
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_resource_type, arg_property_name, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_property_name)
	result.P = ret.Pointer()
	return
}

// gom_filter_new_is_not_null
//
// [ resource_type ] trans: nothing
//
// [ property_name ] trans: nothing
//
// [ result ] trans: nothing
//
func NewFilterIsNotNull(resource_type gi.GType, property_name string) (result Filter) {
	iv, err := _I.Get(47, "Filter", "new_is_not_null", 14, 6, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	arg_resource_type := gi.NewUintArgument(uint(resource_type))
	arg_property_name := gi.NewStringArgument(c_property_name)
	args := []gi.Argument{arg_resource_type, arg_property_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_property_name)
	result.P = ret.Pointer()
	return
}

// gom_filter_new_is_null
//
// [ resource_type ] trans: nothing
//
// [ property_name ] trans: nothing
//
// [ result ] trans: nothing
//
func NewFilterIsNull(resource_type gi.GType, property_name string) (result Filter) {
	iv, err := _I.Get(48, "Filter", "new_is_null", 14, 7, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	arg_resource_type := gi.NewUintArgument(uint(resource_type))
	arg_property_name := gi.NewStringArgument(c_property_name)
	args := []gi.Argument{arg_resource_type, arg_property_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_property_name)
	result.P = ret.Pointer()
	return
}

// gom_filter_new_like
//
// [ resource_type ] trans: nothing
//
// [ property_name ] trans: nothing
//
// [ value ] trans: nothing
//
// [ result ] trans: nothing
//
func NewFilterLike(resource_type gi.GType, property_name string, value g.Value) (result Filter) {
	iv, err := _I.Get(49, "Filter", "new_like", 14, 8, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	arg_resource_type := gi.NewUintArgument(uint(resource_type))
	arg_property_name := gi.NewStringArgument(c_property_name)
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_resource_type, arg_property_name, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_property_name)
	result.P = ret.Pointer()
	return
}

// gom_filter_new_lt
//
// [ resource_type ] trans: nothing
//
// [ property_name ] trans: nothing
//
// [ value ] trans: nothing
//
// [ result ] trans: nothing
//
func NewFilterLt(resource_type gi.GType, property_name string, value g.Value) (result Filter) {
	iv, err := _I.Get(50, "Filter", "new_lt", 14, 9, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	arg_resource_type := gi.NewUintArgument(uint(resource_type))
	arg_property_name := gi.NewStringArgument(c_property_name)
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_resource_type, arg_property_name, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_property_name)
	result.P = ret.Pointer()
	return
}

// gom_filter_new_lte
//
// [ resource_type ] trans: nothing
//
// [ property_name ] trans: nothing
//
// [ value ] trans: nothing
//
// [ result ] trans: nothing
//
func NewFilterLte(resource_type gi.GType, property_name string, value g.Value) (result Filter) {
	iv, err := _I.Get(51, "Filter", "new_lte", 14, 10, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	arg_resource_type := gi.NewUintArgument(uint(resource_type))
	arg_property_name := gi.NewStringArgument(c_property_name)
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_resource_type, arg_property_name, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_property_name)
	result.P = ret.Pointer()
	return
}

// gom_filter_new_neq
//
// [ resource_type ] trans: nothing
//
// [ property_name ] trans: nothing
//
// [ value ] trans: nothing
//
// [ result ] trans: nothing
//
func NewFilterNeq(resource_type gi.GType, property_name string, value g.Value) (result Filter) {
	iv, err := _I.Get(52, "Filter", "new_neq", 14, 11, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	arg_resource_type := gi.NewUintArgument(uint(resource_type))
	arg_property_name := gi.NewStringArgument(c_property_name)
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_resource_type, arg_property_name, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_property_name)
	result.P = ret.Pointer()
	return
}

// gom_filter_new_or
//
// [ left ] trans: nothing
//
// [ right ] trans: nothing
//
// [ result ] trans: everything
//
func NewFilterOr(left IFilter, right IFilter) (result Filter) {
	iv, err := _I.Get(53, "Filter", "new_or", 14, 12, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if left != nil {
		tmp = left.P_Filter()
	}
	var tmp1 unsafe.Pointer
	if right != nil {
		tmp1 = right.P_Filter()
	}
	arg_left := gi.NewPointerArgument(tmp)
	arg_right := gi.NewPointerArgument(tmp1)
	args := []gi.Argument{arg_left, arg_right}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// gom_filter_new_or_fullv
//
// [ filter_array ] trans: nothing
//
// [ result ] trans: everything
//
func NewFilterOrFullv(filter_array IFilter) (result Filter) {
	iv, err := _I.Get(54, "Filter", "new_or_fullv", 14, 13, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if filter_array != nil {
		tmp = filter_array.P_Filter()
	}
	arg_filter_array := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_filter_array}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// gom_filter_new_sql
//
// [ sql ] trans: nothing
//
// [ values ] trans: nothing
//
// [ result ] trans: everything
//
func NewFilterSql(sql string, values int /*TODO_TYPE isPtr: true, tag: array*/) (result Filter) {
	iv, err := _I.Get(55, "Filter", "new_sql", 14, 14, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_sql := gi.CString(sql)
	arg_sql := gi.NewStringArgument(c_sql)
	arg_values := gi.NewIntArgument(values) /*TODO*/
	args := []gi.Argument{arg_sql, arg_values}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_sql)
	result.P = ret.Pointer()
	return
}

// gom_filter_get_sql
//
// [ table_map ] trans: nothing
//
// [ result ] trans: everything
//
func (v Filter) GetSql(table_map g.HashTable) (result string) {
	iv, err := _I.Get(56, "Filter", "get_sql", 14, 15, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_table_map := gi.NewPointerArgument(table_map.P)
	args := []gi.Argument{arg_v, arg_table_map}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// gom_filter_get_values
//
// [ result ] trans: everything
//
func (v Filter) GetValues() (result int /*TODO_TYPE array type: 1, isZeroTerm: false*/) {
	iv, err := _I.Get(57, "Filter", "get_values", 14, 16, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int() /*TODO*/
	return
}

// ignore GType struct FilterClass

// Enum FilterMode
type FilterModeEnum int

const (
	FilterModeSql       FilterModeEnum = 1
	FilterModeOr        FilterModeEnum = 2
	FilterModeAnd       FilterModeEnum = 3
	FilterModeEq        FilterModeEnum = 4
	FilterModeNeq       FilterModeEnum = 5
	FilterModeGt        FilterModeEnum = 6
	FilterModeGte       FilterModeEnum = 7
	FilterModeLt        FilterModeEnum = 8
	FilterModeLte       FilterModeEnum = 9
	FilterModeLike      FilterModeEnum = 10
	FilterModeGlob      FilterModeEnum = 11
	FilterModeIsNull    FilterModeEnum = 12
	FilterModeIsNotNull FilterModeEnum = 13
)

func FilterModeGetType() gi.GType {
	ret := _I.GetGType(10, "FilterMode")
	return ret
}

// Struct FilterPrivate
type FilterPrivate struct {
	P unsafe.Pointer
}

func FilterPrivateGetType() gi.GType {
	ret := _I.GetGType(11, "FilterPrivate")
	return ret
}

// Object Repository
type Repository struct {
	g.Object
}

func WrapRepository(p unsafe.Pointer) (r Repository) { r.P = p; return }

type IRepository interface{ P_Repository() unsafe.Pointer }

func (v Repository) P_Repository() unsafe.Pointer { return v.P }
func RepositoryGetType() gi.GType {
	ret := _I.GetGType(12, "Repository")
	return ret
}

// gom_repository_new
//
// [ adapter ] trans: nothing
//
// [ result ] trans: everything
//
func NewRepository(adapter IAdapter) (result Repository) {
	iv, err := _I.Get(58, "Repository", "new", 18, 0, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if adapter != nil {
		tmp = adapter.P_Adapter()
	}
	arg_adapter := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_adapter}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// gom_repository_automatic_migrate_async
//
// [ version ] trans: nothing
//
// [ object_types ] trans: container
//
// [ callback ] trans: nothing
//
// [ user_data ] trans: nothing
//
func (v Repository) AutomaticMigrateAsync(version uint32, object_types g.List, callback g.AsyncReadyCallback) {
	iv, err := _I.Get(59, "Repository", "automatic_migrate_async", 18, 1, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var funcPtr unsafe.Pointer
	if callback != nil {
		callableInfo := gi.GetCallableInfo("Gio", "AsyncReadyCallback")
		_, funcPtr = gi.RegisterFClosure(func(__result unsafe.Pointer, __args []unsafe.Pointer) {
			g.CallAsyncReadyCallback(callback, __result, __args)
		}, gi.ScopeAsync, callableInfo)
		callableInfo.Unref()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_version := gi.NewUint32Argument(version)
	arg_object_types := gi.NewPointerArgument(object_types.P)
	arg_callback := gi.NewPointerArgument(funcPtr)
	arg_user_data := gi.NewPointerArgument(nil)
	args := []gi.Argument{arg_v, arg_version, arg_object_types, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// gom_repository_automatic_migrate_finish
//
// [ result ] trans: nothing
//
// [ result1 ] trans: nothing
//
func (v Repository) AutomaticMigrateFinish(result g.IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(60, "Repository", "automatic_migrate_finish", 18, 2, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// gom_repository_automatic_migrate_sync
//
// [ version ] trans: nothing
//
// [ object_types ] trans: container
//
// [ result ] trans: nothing
//
func (v Repository) AutomaticMigrateSync(version uint32, object_types g.List) (result bool, err error) {
	iv, err := _I.Get(61, "Repository", "automatic_migrate_sync", 18, 3, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_version := gi.NewUint32Argument(version)
	arg_object_types := gi.NewPointerArgument(object_types.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_version, arg_object_types, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// gom_repository_find_async
//
// [ resource_type ] trans: nothing
//
// [ filter ] trans: nothing
//
// [ callback ] trans: nothing
//
// [ user_data ] trans: nothing
//
func (v Repository) FindAsync(resource_type gi.GType, filter IFilter, callback g.AsyncReadyCallback) {
	iv, err := _I.Get(62, "Repository", "find_async", 18, 4, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if filter != nil {
		tmp = filter.P_Filter()
	}
	var funcPtr unsafe.Pointer
	if callback != nil {
		callableInfo := gi.GetCallableInfo("Gio", "AsyncReadyCallback")
		_, funcPtr = gi.RegisterFClosure(func(__result unsafe.Pointer, __args []unsafe.Pointer) {
			g.CallAsyncReadyCallback(callback, __result, __args)
		}, gi.ScopeAsync, callableInfo)
		callableInfo.Unref()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_resource_type := gi.NewUintArgument(uint(resource_type))
	arg_filter := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewPointerArgument(funcPtr)
	arg_user_data := gi.NewPointerArgument(nil)
	args := []gi.Argument{arg_v, arg_resource_type, arg_filter, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// gom_repository_find_finish
//
// [ result ] trans: nothing
//
// [ result1 ] trans: everything
//
func (v Repository) FindFinish(result g.IAsyncResult) (result1 ResourceGroup, err error) {
	iv, err := _I.Get(63, "Repository", "find_finish", 18, 5, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// gom_repository_find_one_async
//
// [ resource_type ] trans: nothing
//
// [ filter ] trans: nothing
//
// [ callback ] trans: nothing
//
// [ user_data ] trans: nothing
//
func (v Repository) FindOneAsync(resource_type gi.GType, filter IFilter, callback g.AsyncReadyCallback) {
	iv, err := _I.Get(64, "Repository", "find_one_async", 18, 6, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if filter != nil {
		tmp = filter.P_Filter()
	}
	var funcPtr unsafe.Pointer
	if callback != nil {
		callableInfo := gi.GetCallableInfo("Gio", "AsyncReadyCallback")
		_, funcPtr = gi.RegisterFClosure(func(__result unsafe.Pointer, __args []unsafe.Pointer) {
			g.CallAsyncReadyCallback(callback, __result, __args)
		}, gi.ScopeAsync, callableInfo)
		callableInfo.Unref()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_resource_type := gi.NewUintArgument(uint(resource_type))
	arg_filter := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewPointerArgument(funcPtr)
	arg_user_data := gi.NewPointerArgument(nil)
	args := []gi.Argument{arg_v, arg_resource_type, arg_filter, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// gom_repository_find_one_finish
//
// [ result ] trans: nothing
//
// [ result1 ] trans: everything
//
func (v Repository) FindOneFinish(result g.IAsyncResult) (result1 Resource, err error) {
	iv, err := _I.Get(65, "Repository", "find_one_finish", 18, 7, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// gom_repository_find_one_sync
//
// [ resource_type ] trans: nothing
//
// [ filter ] trans: nothing
//
// [ result ] trans: everything
//
func (v Repository) FindOneSync(resource_type gi.GType, filter IFilter) (result Resource, err error) {
	iv, err := _I.Get(66, "Repository", "find_one_sync", 18, 8, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if filter != nil {
		tmp = filter.P_Filter()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_resource_type := gi.NewUintArgument(uint(resource_type))
	arg_filter := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_resource_type, arg_filter, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// gom_repository_find_sorted_async
//
// [ resource_type ] trans: nothing
//
// [ filter ] trans: nothing
//
// [ sorting ] trans: nothing
//
// [ callback ] trans: nothing
//
// [ user_data ] trans: nothing
//
func (v Repository) FindSortedAsync(resource_type gi.GType, filter IFilter, sorting ISorting, callback g.AsyncReadyCallback) {
	iv, err := _I.Get(67, "Repository", "find_sorted_async", 18, 9, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if filter != nil {
		tmp = filter.P_Filter()
	}
	var tmp1 unsafe.Pointer
	if sorting != nil {
		tmp1 = sorting.P_Sorting()
	}
	var funcPtr unsafe.Pointer
	if callback != nil {
		callableInfo := gi.GetCallableInfo("Gio", "AsyncReadyCallback")
		_, funcPtr = gi.RegisterFClosure(func(__result unsafe.Pointer, __args []unsafe.Pointer) {
			g.CallAsyncReadyCallback(callback, __result, __args)
		}, gi.ScopeAsync, callableInfo)
		callableInfo.Unref()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_resource_type := gi.NewUintArgument(uint(resource_type))
	arg_filter := gi.NewPointerArgument(tmp)
	arg_sorting := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewPointerArgument(funcPtr)
	arg_user_data := gi.NewPointerArgument(nil)
	args := []gi.Argument{arg_v, arg_resource_type, arg_filter, arg_sorting, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// gom_repository_find_sorted_sync
//
// [ resource_type ] trans: nothing
//
// [ filter ] trans: nothing
//
// [ sorting ] trans: nothing
//
// [ result ] trans: everything
//
func (v Repository) FindSortedSync(resource_type gi.GType, filter IFilter, sorting ISorting) (result ResourceGroup, err error) {
	iv, err := _I.Get(68, "Repository", "find_sorted_sync", 18, 10, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if filter != nil {
		tmp = filter.P_Filter()
	}
	var tmp1 unsafe.Pointer
	if sorting != nil {
		tmp1 = sorting.P_Sorting()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_resource_type := gi.NewUintArgument(uint(resource_type))
	arg_filter := gi.NewPointerArgument(tmp)
	arg_sorting := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_resource_type, arg_filter, arg_sorting, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// gom_repository_find_sync
//
// [ resource_type ] trans: nothing
//
// [ filter ] trans: nothing
//
// [ result ] trans: everything
//
func (v Repository) FindSync(resource_type gi.GType, filter IFilter) (result ResourceGroup, err error) {
	iv, err := _I.Get(69, "Repository", "find_sync", 18, 11, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if filter != nil {
		tmp = filter.P_Filter()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_resource_type := gi.NewUintArgument(uint(resource_type))
	arg_filter := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_resource_type, arg_filter, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// gom_repository_get_adapter
//
// [ result ] trans: nothing
//
func (v Repository) GetAdapter() (result Adapter) {
	iv, err := _I.Get(70, "Repository", "get_adapter", 18, 12, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// gom_repository_migrate_async
//
// [ version ] trans: nothing
//
// [ migrator ] trans: nothing
//
// [ migrator_data ] trans: nothing
//
// [ callback ] trans: nothing
//
// [ user_data ] trans: nothing
//
func (v Repository) MigrateAsync(version uint32, migrator RepositoryMigrator, callback g.AsyncReadyCallback) {
	iv, err := _I.Get(71, "Repository", "migrate_async", 18, 13, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var funcPtr unsafe.Pointer
	if migrator != nil {
		callableInfo := gi.GetCallableInfo("Gom", "RepositoryMigrator")
		_, funcPtr = gi.RegisterFClosure(func(__result unsafe.Pointer, __args []unsafe.Pointer) {
			CallRepositoryMigrator(migrator, __result, __args)
		}, gi.ScopeAsync, callableInfo)
		callableInfo.Unref()
	}
	var funcPtr1 unsafe.Pointer
	if callback != nil {
		callableInfo1 := gi.GetCallableInfo("Gio", "AsyncReadyCallback")
		_, funcPtr1 = gi.RegisterFClosure(func(__result unsafe.Pointer, __args []unsafe.Pointer) {
			g.CallAsyncReadyCallback(callback, __result, __args)
		}, gi.ScopeAsync, callableInfo1)
		callableInfo1.Unref()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_version := gi.NewUint32Argument(version)
	arg_migrator := gi.NewPointerArgument(funcPtr)
	arg_migrator_data := gi.NewPointerArgument(nil)
	arg_callback := gi.NewPointerArgument(funcPtr1)
	arg_user_data := gi.NewPointerArgument(nil)
	args := []gi.Argument{arg_v, arg_version, arg_migrator, arg_migrator_data, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// gom_repository_migrate_finish
//
// [ result ] trans: nothing
//
// [ result1 ] trans: nothing
//
func (v Repository) MigrateFinish(result g.IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(72, "Repository", "migrate_finish", 18, 14, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// gom_repository_migrate_sync
//
// [ version ] trans: nothing
//
// [ migrator ] trans: nothing
//
// [ migrator_data ] trans: nothing
//
// [ result ] trans: nothing
//
func (v Repository) MigrateSync(version uint32, migrator RepositoryMigrator) (result bool, err error) {
	iv, err := _I.Get(73, "Repository", "migrate_sync", 18, 15, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var cId uint
	var funcPtr unsafe.Pointer
	if migrator != nil {
		callableInfo := gi.GetCallableInfo("Gom", "RepositoryMigrator")
		cId, funcPtr = gi.RegisterFClosure(func(__result unsafe.Pointer, __args []unsafe.Pointer) {
			CallRepositoryMigrator(migrator, __result, __args)
		}, gi.ScopeCall, callableInfo)
		callableInfo.Unref()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_version := gi.NewUint32Argument(version)
	arg_migrator := gi.NewPointerArgument(funcPtr)
	arg_migrator_data := gi.NewPointerArgument(nil)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_version, arg_migrator, arg_migrator_data, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.UnregisterFClosure(cId)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// ignore GType struct RepositoryClass

type RepositoryMigrator func(repository Repository, adapter Adapter, version uint32) (result bool)

func CallRepositoryMigrator(fn RepositoryMigrator, result unsafe.Pointer, args []unsafe.Pointer) {
	if fn == nil {
		return
	}
	repository := WrapRepository(*(*unsafe.Pointer)(args[0]))
	adapter := WrapAdapter(*(*unsafe.Pointer)(args[1]))
	version := *(*uint32)(args[2])
	fnRet := fn(repository, adapter, version)
	*(*int32)(result) = int32(gi.Bool2Int(fnRet))
}

// Struct RepositoryPrivate
type RepositoryPrivate struct {
	P unsafe.Pointer
}

func RepositoryPrivateGetType() gi.GType {
	ret := _I.GetGType(13, "RepositoryPrivate")
	return ret
}

// Object Resource
type Resource struct {
	g.Object
}

func WrapResource(p unsafe.Pointer) (r Resource) { r.P = p; return }

type IResource interface{ P_Resource() unsafe.Pointer }

func (v Resource) P_Resource() unsafe.Pointer { return v.P }
func ResourceGetType() gi.GType {
	ret := _I.GetGType(14, "Resource")
	return ret
}

// gom_resource_from_bytes_func_quark
//
// [ result ] trans: nothing
//
func ResourceFromBytesFuncQuark1() (result uint32) {
	iv, err := _I.Get(74, "Resource", "from_bytes_func_quark", 22, 0, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result = ret.Uint32()
	return
}

// gom_resource_new_in_version_quark
//
// [ result ] trans: nothing
//
func ResourceNewInVersionQuark1() (result uint32) {
	iv, err := _I.Get(75, "Resource", "new_in_version_quark", 22, 1, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result = ret.Uint32()
	return
}

// gom_resource_not_mapped_quark
//
// [ result ] trans: nothing
//
func ResourceNotMappedQuark1() (result uint32) {
	iv, err := _I.Get(76, "Resource", "not_mapped_quark", 22, 2, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result = ret.Uint32()
	return
}

// gom_resource_notnull
//
// [ result ] trans: nothing
//
func ResourceNotnull1() (result uint32) {
	iv, err := _I.Get(77, "Resource", "notnull", 22, 3, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result = ret.Uint32()
	return
}

// gom_resource_ref_property_name
//
// [ result ] trans: nothing
//
func ResourceRefPropertyName1() (result uint32) {
	iv, err := _I.Get(78, "Resource", "ref_property_name", 22, 4, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result = ret.Uint32()
	return
}

// gom_resource_ref_table_class
//
// [ result ] trans: nothing
//
func ResourceRefTableClass1() (result uint32) {
	iv, err := _I.Get(79, "Resource", "ref_table_class", 22, 5, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result = ret.Uint32()
	return
}

// gom_resource_to_bytes_func_quark
//
// [ result ] trans: nothing
//
func ResourceToBytesFuncQuark1() (result uint32) {
	iv, err := _I.Get(80, "Resource", "to_bytes_func_quark", 22, 6, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result = ret.Uint32()
	return
}

// gom_resource_unique
//
// [ result ] trans: nothing
//
func ResourceUnique1() (result uint32) {
	iv, err := _I.Get(81, "Resource", "unique", 22, 7, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result = ret.Uint32()
	return
}

// gom_resource_delete_async
//
// [ callback ] trans: nothing
//
// [ user_data ] trans: nothing
//
func (v Resource) DeleteAsync(callback g.AsyncReadyCallback) {
	iv, err := _I.Get(82, "Resource", "delete_async", 22, 8, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var funcPtr unsafe.Pointer
	if callback != nil {
		callableInfo := gi.GetCallableInfo("Gio", "AsyncReadyCallback")
		_, funcPtr = gi.RegisterFClosure(func(__result unsafe.Pointer, __args []unsafe.Pointer) {
			g.CallAsyncReadyCallback(callback, __result, __args)
		}, gi.ScopeAsync, callableInfo)
		callableInfo.Unref()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_callback := gi.NewPointerArgument(funcPtr)
	arg_user_data := gi.NewPointerArgument(nil)
	args := []gi.Argument{arg_v, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// gom_resource_delete_finish
//
// [ result ] trans: nothing
//
// [ result1 ] trans: nothing
//
func (v Resource) DeleteFinish(result g.IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(83, "Resource", "delete_finish", 22, 9, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// gom_resource_delete_sync
//
// [ result ] trans: nothing
//
func (v Resource) DeleteSync() (result bool, err error) {
	iv, err := _I.Get(84, "Resource", "delete_sync", 22, 10, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// gom_resource_fetch_m2m_async
//
// [ resource_type ] trans: nothing
//
// [ m2m_table ] trans: nothing
//
// [ filter ] trans: nothing
//
// [ callback ] trans: nothing
//
// [ user_data ] trans: nothing
//
func (v Resource) FetchM2mAsync(resource_type gi.GType, m2m_table string, filter IFilter, callback g.AsyncReadyCallback) {
	iv, err := _I.Get(85, "Resource", "fetch_m2m_async", 22, 11, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_m2m_table := gi.CString(m2m_table)
	var tmp unsafe.Pointer
	if filter != nil {
		tmp = filter.P_Filter()
	}
	var funcPtr unsafe.Pointer
	if callback != nil {
		callableInfo := gi.GetCallableInfo("Gio", "AsyncReadyCallback")
		_, funcPtr = gi.RegisterFClosure(func(__result unsafe.Pointer, __args []unsafe.Pointer) {
			g.CallAsyncReadyCallback(callback, __result, __args)
		}, gi.ScopeAsync, callableInfo)
		callableInfo.Unref()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_resource_type := gi.NewUintArgument(uint(resource_type))
	arg_m2m_table := gi.NewStringArgument(c_m2m_table)
	arg_filter := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewPointerArgument(funcPtr)
	arg_user_data := gi.NewPointerArgument(nil)
	args := []gi.Argument{arg_v, arg_resource_type, arg_m2m_table, arg_filter, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_m2m_table)
}

// gom_resource_fetch_m2m_finish
//
// [ result ] trans: nothing
//
// [ result1 ] trans: everything
//
func (v Resource) FetchM2mFinish(result g.IAsyncResult) (result1 ResourceGroup, err error) {
	iv, err := _I.Get(86, "Resource", "fetch_m2m_finish", 22, 12, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// gom_resource_save_async
//
// [ callback ] trans: nothing
//
// [ user_data ] trans: nothing
//
func (v Resource) SaveAsync(callback g.AsyncReadyCallback) {
	iv, err := _I.Get(87, "Resource", "save_async", 22, 13, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var funcPtr unsafe.Pointer
	if callback != nil {
		callableInfo := gi.GetCallableInfo("Gio", "AsyncReadyCallback")
		_, funcPtr = gi.RegisterFClosure(func(__result unsafe.Pointer, __args []unsafe.Pointer) {
			g.CallAsyncReadyCallback(callback, __result, __args)
		}, gi.ScopeAsync, callableInfo)
		callableInfo.Unref()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_callback := gi.NewPointerArgument(funcPtr)
	arg_user_data := gi.NewPointerArgument(nil)
	args := []gi.Argument{arg_v, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// gom_resource_save_finish
//
// [ result ] trans: nothing
//
// [ result1 ] trans: nothing
//
func (v Resource) SaveFinish(result g.IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(88, "Resource", "save_finish", 22, 14, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// gom_resource_save_sync
//
// [ result ] trans: nothing
//
func (v Resource) SaveSync() (result bool, err error) {
	iv, err := _I.Get(89, "Resource", "save_sync", 22, 15, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// Struct ResourceClass
type ResourceClass struct {
	P unsafe.Pointer
}

const SizeOfStructResourceClass = 264

func ResourceClassGetType() gi.GType {
	ret := _I.GetGType(15, "ResourceClass")
	return ret
}

// gom_resource_class_set_notnull
//
// [ property_name ] trans: nothing
//
func (v ResourceClass) SetNotnull(property_name string) {
	iv, err := _I.Get(90, "ResourceClass", "set_notnull", 23, 0, gi.INFO_TYPE_STRUCT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_property_name := gi.NewStringArgument(c_property_name)
	args := []gi.Argument{arg_v, arg_property_name}
	iv.Call(args, nil, nil)
	gi.Free(c_property_name)
}

// gom_resource_class_set_primary_key
//
// [ primary_key ] trans: nothing
//
func (v ResourceClass) SetPrimaryKey(primary_key string) {
	iv, err := _I.Get(91, "ResourceClass", "set_primary_key", 23, 1, gi.INFO_TYPE_STRUCT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_primary_key := gi.CString(primary_key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_primary_key := gi.NewStringArgument(c_primary_key)
	args := []gi.Argument{arg_v, arg_primary_key}
	iv.Call(args, nil, nil)
	gi.Free(c_primary_key)
}

// gom_resource_class_set_property_from_bytes
//
// [ property_name ] trans: nothing
//
// [ from_bytes_func ] trans: nothing
//
// [ notify ] trans: nothing
//
func (v ResourceClass) SetPropertyFromBytes(property_name string, from_bytes_func ResourceFromBytesFunc) {
	iv, err := _I.Get(92, "ResourceClass", "set_property_from_bytes", 23, 2, gi.INFO_TYPE_STRUCT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	var funcPtr unsafe.Pointer
	if from_bytes_func != nil {
		callableInfo := gi.GetCallableInfo("Gom", "ResourceFromBytesFunc")
		_, funcPtr = gi.RegisterFClosure(func(__result unsafe.Pointer, __args []unsafe.Pointer) {
			CallResourceFromBytesFunc(from_bytes_func, __result, __args)
		}, gi.ScopeNotified, callableInfo)
		callableInfo.Unref()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_property_name := gi.NewStringArgument(c_property_name)
	arg_from_bytes_func := gi.NewPointerArgument(funcPtr)
	arg_notify := gi.NewPointerArgument(gi.GetClosureDestroyNotifyPtr())
	args := []gi.Argument{arg_v, arg_property_name, arg_from_bytes_func, arg_notify}
	iv.Call(args, nil, nil)
	gi.Free(c_property_name)
}

// gom_resource_class_set_property_new_in_version
//
// [ property_name ] trans: nothing
//
// [ version ] trans: nothing
//
func (v ResourceClass) SetPropertyNewInVersion(property_name string, version uint32) {
	iv, err := _I.Get(93, "ResourceClass", "set_property_new_in_version", 23, 3, gi.INFO_TYPE_STRUCT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_property_name := gi.NewStringArgument(c_property_name)
	arg_version := gi.NewUint32Argument(version)
	args := []gi.Argument{arg_v, arg_property_name, arg_version}
	iv.Call(args, nil, nil)
	gi.Free(c_property_name)
}

// gom_resource_class_set_property_set_mapped
//
// [ property_name ] trans: nothing
//
// [ is_mapped ] trans: nothing
//
func (v ResourceClass) SetPropertySetMapped(property_name string, is_mapped bool) {
	iv, err := _I.Get(94, "ResourceClass", "set_property_set_mapped", 23, 4, gi.INFO_TYPE_STRUCT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_property_name := gi.NewStringArgument(c_property_name)
	arg_is_mapped := gi.NewBoolArgument(is_mapped)
	args := []gi.Argument{arg_v, arg_property_name, arg_is_mapped}
	iv.Call(args, nil, nil)
	gi.Free(c_property_name)
}

// gom_resource_class_set_property_to_bytes
//
// [ property_name ] trans: nothing
//
// [ to_bytes_func ] trans: nothing
//
// [ notify ] trans: nothing
//
func (v ResourceClass) SetPropertyToBytes(property_name string, to_bytes_func ResourceToBytesFunc) {
	iv, err := _I.Get(95, "ResourceClass", "set_property_to_bytes", 23, 5, gi.INFO_TYPE_STRUCT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	var funcPtr unsafe.Pointer
	if to_bytes_func != nil {
		callableInfo := gi.GetCallableInfo("Gom", "ResourceToBytesFunc")
		_, funcPtr = gi.RegisterFClosure(func(__result unsafe.Pointer, __args []unsafe.Pointer) {
			CallResourceToBytesFunc(to_bytes_func, __result, __args)
		}, gi.ScopeNotified, callableInfo)
		callableInfo.Unref()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_property_name := gi.NewStringArgument(c_property_name)
	arg_to_bytes_func := gi.NewPointerArgument(funcPtr)
	arg_notify := gi.NewPointerArgument(gi.GetClosureDestroyNotifyPtr())
	args := []gi.Argument{arg_v, arg_property_name, arg_to_bytes_func, arg_notify}
	iv.Call(args, nil, nil)
	gi.Free(c_property_name)
}

// gom_resource_class_set_reference
//
// [ property_name ] trans: nothing
//
// [ ref_table_name ] trans: nothing
//
// [ ref_property_name ] trans: nothing
//
func (v ResourceClass) SetReference(property_name string, ref_table_name string, ref_property_name string) {
	iv, err := _I.Get(96, "ResourceClass", "set_reference", 23, 6, gi.INFO_TYPE_STRUCT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	c_ref_table_name := gi.CString(ref_table_name)
	c_ref_property_name := gi.CString(ref_property_name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_property_name := gi.NewStringArgument(c_property_name)
	arg_ref_table_name := gi.NewStringArgument(c_ref_table_name)
	arg_ref_property_name := gi.NewStringArgument(c_ref_property_name)
	args := []gi.Argument{arg_v, arg_property_name, arg_ref_table_name, arg_ref_property_name}
	iv.Call(args, nil, nil)
	gi.Free(c_property_name)
	gi.Free(c_ref_table_name)
	gi.Free(c_ref_property_name)
}

// gom_resource_class_set_table
//
// [ table ] trans: nothing
//
func (v ResourceClass) SetTable(table string) {
	iv, err := _I.Get(97, "ResourceClass", "set_table", 23, 7, gi.INFO_TYPE_STRUCT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_table := gi.CString(table)
	arg_v := gi.NewPointerArgument(v.P)
	arg_table := gi.NewStringArgument(c_table)
	args := []gi.Argument{arg_v, arg_table}
	iv.Call(args, nil, nil)
	gi.Free(c_table)
}

// gom_resource_class_set_unique
//
// [ property_name ] trans: nothing
//
func (v ResourceClass) SetUnique(property_name string) {
	iv, err := _I.Get(98, "ResourceClass", "set_unique", 23, 8, gi.INFO_TYPE_STRUCT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_property_name := gi.NewStringArgument(c_property_name)
	args := []gi.Argument{arg_v, arg_property_name}
	iv.Call(args, nil, nil)
	gi.Free(c_property_name)
}

type ResourceFromBytesFunc func(bytes g.Bytes, value g.Value)

func CallResourceFromBytesFunc(fn ResourceFromBytesFunc, result unsafe.Pointer, args []unsafe.Pointer) {
	if fn == nil {
		return
	}
	bytes := g.Bytes{P: *(*unsafe.Pointer)(args[0])}
	value := g.Value{P: *(*unsafe.Pointer)(args[1])}
	fn(bytes, value)
}

// Object ResourceGroup
type ResourceGroup struct {
	g.Object
}

func WrapResourceGroup(p unsafe.Pointer) (r ResourceGroup) { r.P = p; return }

type IResourceGroup interface{ P_ResourceGroup() unsafe.Pointer }

func (v ResourceGroup) P_ResourceGroup() unsafe.Pointer { return v.P }
func ResourceGroupGetType() gi.GType {
	ret := _I.GetGType(16, "ResourceGroup")
	return ret
}

// gom_resource_group_new
//
// [ repository ] trans: nothing
//
// [ result ] trans: everything
//
func NewResourceGroup(repository IRepository) (result ResourceGroup) {
	iv, err := _I.Get(99, "ResourceGroup", "new", 25, 0, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if repository != nil {
		tmp = repository.P_Repository()
	}
	arg_repository := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_repository}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// gom_resource_group_append
//
// [ resource ] trans: nothing
//
// [ result ] trans: nothing
//
func (v ResourceGroup) Append(resource IResource) (result bool) {
	iv, err := _I.Get(100, "ResourceGroup", "append", 25, 1, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if resource != nil {
		tmp = resource.P_Resource()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_resource := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_resource}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// gom_resource_group_delete_async
//
// [ callback ] trans: nothing
//
// [ user_data ] trans: nothing
//
func (v ResourceGroup) DeleteAsync(callback g.AsyncReadyCallback) {
	iv, err := _I.Get(101, "ResourceGroup", "delete_async", 25, 2, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var funcPtr unsafe.Pointer
	if callback != nil {
		callableInfo := gi.GetCallableInfo("Gio", "AsyncReadyCallback")
		_, funcPtr = gi.RegisterFClosure(func(__result unsafe.Pointer, __args []unsafe.Pointer) {
			g.CallAsyncReadyCallback(callback, __result, __args)
		}, gi.ScopeAsync, callableInfo)
		callableInfo.Unref()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_callback := gi.NewPointerArgument(funcPtr)
	arg_user_data := gi.NewPointerArgument(nil)
	args := []gi.Argument{arg_v, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// gom_resource_group_delete_finish
//
// [ result ] trans: nothing
//
// [ result1 ] trans: nothing
//
func (v ResourceGroup) DeleteFinish(result g.IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(102, "ResourceGroup", "delete_finish", 25, 3, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// gom_resource_group_delete_sync
//
// [ result ] trans: nothing
//
func (v ResourceGroup) DeleteSync() (result bool, err error) {
	iv, err := _I.Get(103, "ResourceGroup", "delete_sync", 25, 4, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// gom_resource_group_fetch_async
//
// [ index_ ] trans: nothing
//
// [ count ] trans: nothing
//
// [ callback ] trans: nothing
//
// [ user_data ] trans: nothing
//
func (v ResourceGroup) FetchAsync(index_ uint32, count uint32, callback g.AsyncReadyCallback) {
	iv, err := _I.Get(104, "ResourceGroup", "fetch_async", 25, 5, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var funcPtr unsafe.Pointer
	if callback != nil {
		callableInfo := gi.GetCallableInfo("Gio", "AsyncReadyCallback")
		_, funcPtr = gi.RegisterFClosure(func(__result unsafe.Pointer, __args []unsafe.Pointer) {
			g.CallAsyncReadyCallback(callback, __result, __args)
		}, gi.ScopeAsync, callableInfo)
		callableInfo.Unref()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_index_ := gi.NewUint32Argument(index_)
	arg_count := gi.NewUint32Argument(count)
	arg_callback := gi.NewPointerArgument(funcPtr)
	arg_user_data := gi.NewPointerArgument(nil)
	args := []gi.Argument{arg_v, arg_index_, arg_count, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// gom_resource_group_fetch_finish
//
// [ result ] trans: nothing
//
// [ result1 ] trans: nothing
//
func (v ResourceGroup) FetchFinish(result g.IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(105, "ResourceGroup", "fetch_finish", 25, 6, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// gom_resource_group_fetch_sync
//
// [ index_ ] trans: nothing
//
// [ count ] trans: nothing
//
// [ result ] trans: nothing
//
func (v ResourceGroup) FetchSync(index_ uint32, count uint32) (result bool, err error) {
	iv, err := _I.Get(106, "ResourceGroup", "fetch_sync", 25, 7, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_index_ := gi.NewUint32Argument(index_)
	arg_count := gi.NewUint32Argument(count)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_index_, arg_count, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// gom_resource_group_get_count
//
// [ result ] trans: nothing
//
func (v ResourceGroup) GetCount() (result uint32) {
	iv, err := _I.Get(107, "ResourceGroup", "get_count", 25, 8, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// gom_resource_group_get_index
//
// [ index_ ] trans: nothing
//
// [ result ] trans: nothing
//
func (v ResourceGroup) GetIndex(index_ uint32) (result Resource) {
	iv, err := _I.Get(108, "ResourceGroup", "get_index", 25, 9, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_index_ := gi.NewUint32Argument(index_)
	args := []gi.Argument{arg_v, arg_index_}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// gom_resource_group_get_m2m_table
//
// [ result ] trans: nothing
//
func (v ResourceGroup) GetM2mTable() (result string) {
	iv, err := _I.Get(109, "ResourceGroup", "get_m2m_table", 25, 10, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Copy()
	return
}

// gom_resource_group_write_async
//
// [ callback ] trans: nothing
//
// [ user_data ] trans: nothing
//
func (v ResourceGroup) WriteAsync(callback g.AsyncReadyCallback) {
	iv, err := _I.Get(110, "ResourceGroup", "write_async", 25, 11, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var funcPtr unsafe.Pointer
	if callback != nil {
		callableInfo := gi.GetCallableInfo("Gio", "AsyncReadyCallback")
		_, funcPtr = gi.RegisterFClosure(func(__result unsafe.Pointer, __args []unsafe.Pointer) {
			g.CallAsyncReadyCallback(callback, __result, __args)
		}, gi.ScopeAsync, callableInfo)
		callableInfo.Unref()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_callback := gi.NewPointerArgument(funcPtr)
	arg_user_data := gi.NewPointerArgument(nil)
	args := []gi.Argument{arg_v, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// gom_resource_group_write_finish
//
// [ result ] trans: nothing
//
// [ result1 ] trans: nothing
//
func (v ResourceGroup) WriteFinish(result g.IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(111, "ResourceGroup", "write_finish", 25, 12, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// gom_resource_group_write_sync
//
// [ result ] trans: nothing
//
func (v ResourceGroup) WriteSync() (result bool, err error) {
	iv, err := _I.Get(112, "ResourceGroup", "write_sync", 25, 13, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// ignore GType struct ResourceGroupClass

// Struct ResourceGroupPrivate
type ResourceGroupPrivate struct {
	P unsafe.Pointer
}

func ResourceGroupPrivateGetType() gi.GType {
	ret := _I.GetGType(17, "ResourceGroupPrivate")
	return ret
}

// Struct ResourcePrivate
type ResourcePrivate struct {
	P unsafe.Pointer
}

func ResourcePrivateGetType() gi.GType {
	ret := _I.GetGType(18, "ResourcePrivate")
	return ret
}

type ResourceToBytesFunc func(value g.Value) (result g.Bytes)

func CallResourceToBytesFunc(fn ResourceToBytesFunc, result unsafe.Pointer, args []unsafe.Pointer) {
	if fn == nil {
		return
	}
	value := g.Value{P: *(*unsafe.Pointer)(args[0])}
	fnRet := fn(value)
	*(*unsafe.Pointer)(result) = fnRet.P
}

// Object Sorting
type Sorting struct {
	g.InitiallyUnowned
}

func WrapSorting(p unsafe.Pointer) (r Sorting) { r.P = p; return }

type ISorting interface{ P_Sorting() unsafe.Pointer }

func (v Sorting) P_Sorting() unsafe.Pointer { return v.P }
func SortingGetType() gi.GType {
	ret := _I.GetGType(19, "Sorting")
	return ret
}

// gom_sorting_add
//
// [ resource_type ] trans: nothing
//
// [ property_name ] trans: nothing
//
// [ sorting_mode ] trans: nothing
//
func (v Sorting) Add(resource_type gi.GType, property_name string, sorting_mode SortingModeEnum) {
	iv, err := _I.Get(113, "Sorting", "add", 30, 0, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_resource_type := gi.NewUintArgument(uint(resource_type))
	arg_property_name := gi.NewStringArgument(c_property_name)
	arg_sorting_mode := gi.NewIntArgument(int(sorting_mode))
	args := []gi.Argument{arg_v, arg_resource_type, arg_property_name, arg_sorting_mode}
	iv.Call(args, nil, nil)
	gi.Free(c_property_name)
}

// gom_sorting_get_sql
//
// [ table_map ] trans: nothing
//
// [ result ] trans: everything
//
func (v Sorting) GetSql(table_map g.HashTable) (result string) {
	iv, err := _I.Get(114, "Sorting", "get_sql", 30, 1, gi.INFO_TYPE_OBJECT, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_table_map := gi.NewPointerArgument(table_map.P)
	args := []gi.Argument{arg_v, arg_table_map}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// ignore GType struct SortingClass

// Enum SortingMode
type SortingModeEnum int

const (
	SortingModeAscending  SortingModeEnum = 1
	SortingModeDescending SortingModeEnum = 2
)

func SortingModeGetType() gi.GType {
	ret := _I.GetGType(20, "SortingMode")
	return ret
}

// Struct SortingPrivate
type SortingPrivate struct {
	P unsafe.Pointer
}

func SortingPrivateGetType() gi.GType {
	ret := _I.GetGType(21, "SortingPrivate")
	return ret
}

// gom_error_quark
//
// [ result ] trans: nothing
//
func ErrorQuark() (result uint32) {
	iv, err := _I.Get(115, "error_quark", "", 34, 0, gi.INFO_TYPE_FUNCTION, 0)
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result = ret.Uint32()
	return
}

// constants
const ()
